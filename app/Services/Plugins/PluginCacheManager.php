<?php

declare(strict_types=1);

namespace App\Services\Plugins;

use App\Models\Plugin;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\File;

/**
 * Plugin Cache Manager - Handles provider cache for fast plugin loading.
 * 
 * This eliminates the DB query on every request by caching active plugin
 * providers in a PHP file that can be opcode-cached.
 * 
 * Cache file format:
 * [
 *     'generated_at' => '2025-12-21T12:00:00Z',
 *     'plugins' => [
 *         'hello-world' => [
 *             'main_class' => 'App\\Plugins\\hello_world\\HelloWorldPlugin',
 *             'path' => '/var/www/app/Plugins/hello-world',
 *         ],
 *     ],
 * ]
 */
class PluginCacheManager
{
    /**
     * Path to the cache file.
     */
    protected string $cachePath;

    /**
     * Cached data (loaded once per request).
     */
    protected ?array $cache = null;

    /**
     * Create a new cache manager instance.
     */
    public function __construct()
    {
        $this->cachePath = base_path('bootstrap/cache/plugins.php');
    }

    /**
     * Get the cache file path.
     */
    public function getCachePath(): string
    {
        return $this->cachePath;
    }

    /**
     * Check if the cache file exists and is valid.
     */
    public function exists(): bool
    {
        return file_exists($this->cachePath) && is_readable($this->cachePath);
    }

    /**
     * Load the cache data.
     * Returns null if cache doesn't exist or is invalid.
     */
    public function load(): ?array
    {
        // Return cached data if already loaded this request
        if ($this->cache !== null) {
            return $this->cache;
        }

        if (!$this->exists()) {
            return null;
        }

        try {
            $data = require $this->cachePath;

            // Validate structure
            if (!is_array($data) || !isset($data['plugins']) || !is_array($data['plugins'])) {
                Log::warning('Plugin cache file has invalid structure, will regenerate');
                return null;
            }

            $this->cache = $data;
            return $data;

        } catch (\Throwable $e) {
            Log::error('Failed to load plugin cache', [
                'error' => $e->getMessage(),
                'path' => $this->cachePath,
            ]);
            return null;
        }
    }

    /**
     * Get active plugins from cache.
     * Returns array of [slug => ['main_class' => ..., 'path' => ...]]
     */
    public function getActivePlugins(): array
    {
        $data = $this->load();
        return $data['plugins'] ?? [];
    }

    /**
     * Rebuild the cache from database.
     * 
     * @param bool $silent If true, don't throw on failure
     * @return bool True if cache was successfully written
     */
    public function rebuild(bool $silent = false): bool
    {
        try {
            // Fetch active plugins from database
            $plugins = Plugin::active()->get();

            $cacheData = [
                'generated_at' => now()->toIso8601String(),
                'plugins' => [],
            ];

            foreach ($plugins as $plugin) {
                $cacheData['plugins'][$plugin->slug] = [
                    'main_class' => $plugin->getMainClassName(),
                    'path' => $plugin->getFullPath(),
                    'version' => $plugin->version,
                ];
            }

            return $this->write($cacheData);

        } catch (\Throwable $e) {
            Log::error('Failed to rebuild plugin cache', [
                'error' => $e->getMessage(),
            ]);

            if (!$silent) {
                throw $e;
            }

            return false;
        }
    }

    /**
     * Write cache data to file atomically.
     * Uses temp file + rename to prevent race conditions.
     */
    protected function write(array $data): bool
    {
        $directory = dirname($this->cachePath);

        // Ensure directory exists
        if (!is_dir($directory)) {
            if (!mkdir($directory, 0755, true)) {
                Log::error('Failed to create cache directory', ['path' => $directory]);
                return false;
            }
        }

        // Generate PHP code
        $content = "<?php\n\n";
        $content .= "// Auto-generated by PluginCacheManager\n";
        $content .= "// Generated at: {$data['generated_at']}\n";
        $content .= "// Do not edit manually - run: php artisan plugins:cache\n\n";
        $content .= "return " . var_export($data, true) . ";\n";

        // Write to temp file first (atomic write pattern)
        $tempPath = $this->cachePath . '.tmp.' . uniqid();

        try {
            if (file_put_contents($tempPath, $content, LOCK_EX) === false) {
                Log::error('Failed to write temp cache file', ['path' => $tempPath]);
                return false;
            }

            // Atomic rename
            if (!rename($tempPath, $this->cachePath)) {
                Log::error('Failed to rename cache file', [
                    'from' => $tempPath,
                    'to' => $this->cachePath,
                ]);
                @unlink($tempPath);
                return false;
            }

            // Clear opcache for this file if available
            if (function_exists('opcache_invalidate')) {
                opcache_invalidate($this->cachePath, true);
            }

            // Clear in-memory cache
            $this->cache = null;

            Log::debug('Plugin cache rebuilt successfully', [
                'plugin_count' => count($data['plugins']),
            ]);

            return true;

        } catch (\Throwable $e) {
            @unlink($tempPath);
            Log::error('Exception writing plugin cache', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Clear the cache file.
     */
    public function clear(): bool
    {
        $this->cache = null;

        if (!$this->exists()) {
            return true;
        }

        try {
            $result = unlink($this->cachePath);

            if ($result && function_exists('opcache_invalidate')) {
                opcache_invalidate($this->cachePath, true);
            }

            return $result;

        } catch (\Throwable $e) {
            Log::error('Failed to clear plugin cache', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Check if cache needs rebuilding.
     * Returns true if cache is missing or a plugin's files have been modified.
     */
    public function needsRebuild(): bool
    {
        if (!$this->exists()) {
            return true;
        }

        $data = $this->load();
        if ($data === null) {
            return true;
        }

        // Check if any plugin path no longer exists
        foreach ($data['plugins'] as $slug => $pluginData) {
            $path = $pluginData['path'] ?? null;
            if ($path && !is_dir($path)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get cache metadata for debugging.
     */
    public function getMetadata(): array
    {
        if (!$this->exists()) {
            return [
                'exists' => false,
                'path' => $this->cachePath,
            ];
        }

        $data = $this->load();

        return [
            'exists' => true,
            'path' => $this->cachePath,
            'generated_at' => $data['generated_at'] ?? 'unknown',
            'plugin_count' => count($data['plugins'] ?? []),
            'plugins' => array_keys($data['plugins'] ?? []),
            'file_size' => filesize($this->cachePath),
            'file_mtime' => date('Y-m-d H:i:s', filemtime($this->cachePath)),
        ];
    }

    /**
     * Mark a plugin as errored (remove from cache without full rebuild).
     */
    public function markPluginError(string $slug): bool
    {
        $data = $this->load();

        if ($data === null) {
            return false;
        }

        if (!isset($data['plugins'][$slug])) {
            return true; // Already not in cache
        }

        unset($data['plugins'][$slug]);
        $data['generated_at'] = now()->toIso8601String();

        return $this->write($data);
    }
}
